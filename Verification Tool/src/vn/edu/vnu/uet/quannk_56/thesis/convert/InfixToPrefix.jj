options{  JAVA_UNICODE_ESCAPE = true;  STATIC = false;  COMMON_TOKEN_ACTION = false;  TOKEN_FACTORY = "Token";  JDK_VERSION = "1.5";  ERROR_REPORTING = true;}PARSER_BEGIN(InfixToPrefix)package vn.edu.vnu.uet.quannk_56.thesis.convert;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.InputStream;import java.io.PrintStream;import java.nio.charset.StandardCharsets;import java.util.Vector;public class InfixToPrefix{  public static String parse(String input)  {    InputStream stream = new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8));    InfixToPrefix parser = new InfixToPrefix(stream);    try    {      return parser.Expression();    }    catch (ParseException e)    {      e.printStackTrace();    }    return "null";  }  public static void main(String args [])  {    InfixToPrefix parser;    if (args.length == 0)    {      System.out.println("Java Parser Version 1.1:  Reading from standard input . . .");      parser = new InfixToPrefix(System.in);    }    else if (args.length == 1)    {      System.out.println("Java Parser Version 1.1:  Reading from file " + args [0] + " . . .");      try      {        parser = new InfixToPrefix(new java.io.FileInputStream(args [0]));      }      catch (java.io.FileNotFoundException e)      {        System.out.println("Java Parser Version 1.1:  File " + args [0] + " not found.");        return;      }    }    else    {      System.out.println("Java Parser Version 1.1:  Usage is one of:");      System.out.println("         java InfixToPrefix < inputfile");      System.out.println("OR");      System.out.println("         java InfixToPrefix inputfile");      return;    }    try    {      String result = parser.Expression();      System.out.println("Java Parser Version 1.1:  Java program parsed successfully.\n\n");      System.out.println(result);    }    catch (ParseException e)    {      System.out.println(e.getMessage());      System.out.println("Java Parser Version 1.1:  Encountered errors during parse.");    }  }}PARSER_END(InfixToPrefix)/* WHITE SPACE */SKIP :{  " "| "\t"| "\n"| "\r"| "\f"}TOKEN :{  < LPAREN : "(" >| < RPAREN : ")" >| < LBRACE : "{" >| < RBRACE : "}" >| < LBRACKET : "[" >| < RBRACKET : "]" >| < SEMICOLON : ";" >| < COMMA : "," >| < DOT : "." >| < AT : "@" >}/* OPERATORS */TOKEN :{  < ASSIGN : "=" >| < LT : "<" >| < BANG : "!" >| < TILDE : "~" >| < HOOK : "?" >| < COLON : ":" >| < EQ : "==" >| < LE : "<=" >| < GE : ">=" >| < NE : "!=" >| < SC_OR : "||" >| < SC_AND : "&&" >| < INCR : "++" >| < DECR : "--" >| < PLUS : "+" >| < MINUS : "-" >| < STAR : "*" >| < SLASH : "/" >| < BIT_AND : "&" >| < BIT_OR : "|" >| < XOR : "^" >| < REM : "%" >| < LSHIFT : "<<" >| < IMPLICATION : "= >" >| < PLUSASSIGN : "+=" >| < MINUSASSIGN : "-=" >| < STARASSIGN : "*=" >| < SLASHASSIGN : "/=" >| < ANDASSIGN : "&=" >| < ORASSIGN : "|=" >| < XORASSIGN : "^=" >| < REMASSIGN : "%=" >| < LSHIFTASSIGN : "<<=" >| < RSIGNEDSHIFTASSIGN : ">>=" >| < RUNSIGNEDSHIFTASSIGN : ">>>=" >| < ELLIPSIS : "..." >}/* >'s need special attention due to generics syntax. */TOKEN :{  < RUNSIGNEDSHIFT : ">>>" >  {    matchedToken.kind = GT;    ((MyToken) matchedToken).realKind = RUNSIGNEDSHIFT;    input_stream.backup(2);    matchedToken.image = ">";  }| < RSIGNEDSHIFT : ">>" >  {    matchedToken.kind = GT;    ((MyToken) matchedToken).realKind = RSIGNEDSHIFT;    input_stream.backup(1);    matchedToken.image = ">";  }| < GT : ">" >}TOKEN :{  < VAR : [ "a"-"z", "A"-"Z", "_", "&" ] ([ "a"-"z", "A"-"Z", "_", "-", "&", "0"-"9", ".", "," ])* >| < NUMBER : [ "0"-"9" ] ([ "0"-"9", ".", "," ])* >}/***************************************** * THE JAVA LANGUAGE GRAMMAR STARTS HERE * *****************************************/String Expression() :/* * This expansion has been written this way instead of: *   Assignment() | ConditionalExpression() * for performance reasons. * However, it is a weakening of the grammar for it allows the LHS of * assignments to be any conditional expression whereas it can only be * a primary expression.  Consider adding a semantic predicate to work * around this. */{  String t, o = "", e = "", result = "";}{  (    t = Term() [ o = Operator() e = Expression() ]    {      if (o.length() == 0) return t;      else return o + " " + t + " " + e;    }  | < LPAREN > t = Expression() < RPAREN > [ o = Operator() e = Expression() ]    {      if (o.length() == 0) return "(" + t + ")";      else return o + " (" + t + ") " + e;    }  | o = Operator() e = Expression()    {      return o + " " + e;    }  )}String Term() :{  Token t;}{  (    t = < VAR >  | t = < NUMBER >  )  {    return t.image;  }}String Operator() :{}{  (    < ASSIGN >  | < BANG >  | < LT >  | < GT >  | < COLON >  | < EQ >  | < LE >  | < GE >  | < NE >  | < SC_OR >  | < SC_AND >  | < PLUS >  | < MINUS >  | < STAR >  | < SLASH >  | < BIT_AND >  | < BIT_OR >  | < XOR >  | < REM >  | < LSHIFT >  | < IMPLICATION >  )  {    return getToken(0).image;  }}