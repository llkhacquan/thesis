options{  JAVA_UNICODE_ESCAPE = true;  STATIC = false;  COMMON_TOKEN_ACTION = false;  TOKEN_FACTORY = "Token";  JDK_VERSION = "1.5";  ERROR_REPORTING = true;}PARSER_BEGIN(InfixToPrefix)package vn.edu.vnu.uet.quannk_56.InfixToPrefix;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.InputStream;import java.io.PrintStream;import java.nio.charset.StandardCharsets;public class InfixToPrefix{  public static String InfixToPrefix(String input)  {    InputStream stream = new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8));    InfixToPrefix parser = new InfixToPrefix(stream);    try    {      return parser.Expression();    }    catch (ParseException e)    {      // TODO Auto-generated catch block
      e.printStackTrace();    }    return "";  }  public static void main(String args [])  {    InfixToPrefix parser;    if (args.length == 0)    {      System.out.println("Java Parser Version 1.1:  Reading from standard input . . .");      parser = new InfixToPrefix(System.in);    }    else if (args.length == 1)    {      System.out.println("Java Parser Version 1.1:  Reading from file " + args [0] + " . . .");      try      {        parser = new InfixToPrefix(new java.io.FileInputStream(args [0]));      }      catch (java.io.FileNotFoundException e)      {        System.out.println("Java Parser Version 1.1:  File " + args [0] + " not found.");        return;      }    }    else    {      System.out.println("Java Parser Version 1.1:  Usage is one of:");      System.out.println("         java InfixToPrefix < inputfile");      System.out.println("OR");      System.out.println("         java InfixToPrefix inputfile");      return;    }    try    {      String result = parser.Expression();      System.out.println("Java Parser Version 1.1:  Java program parsed successfully.\n\n");      System.out.println(result);    }    catch (ParseException e)    {      System.out.println(e.getMessage());      System.out.println("Java Parser Version 1.1:  Encountered errors during parse.");    }  }}PARSER_END(InfixToPrefix)SKIP :{  " "| "\t"| "\n"| "\r"| "\f"}TOKEN :{  < LPAREN : "(" >| < RPAREN : ")" >}/* OPERATORS */TOKEN :{  < ASSIGN : "=" >| < LT : "<" >| < GT : ">" >| < COLON : ":" >| < EQ : "==" >| < LE : "<=" >| < GE : ">=" >| < NE : "!=" >| < SC_OR : "||" >| < SC_AND : "&&" >| < PLUS : "+" >| < MINUS : "-" >| < STAR : "*" >| < SLASH : "/" >| < BIT_AND : "&" >| < BIT_OR : "|" >| < XOR : "^" >| < REM : "%" >| < LSHIFT : "<<" >}TOKEN :{  < Const : "CONST_" ("-")? ([ "0"-"9" ])+ >| < Var : [ "a"-"z", "A"-"Z", "_" ] ([ "a"-"z", "A"-"Z", "_", "0"-"9" ])* >| < Number : [ "0"-"9" ] ([ "0"-"9", ".", "," ])+ >}String Expression() :{  String result, s1, s2, s3;}{  (    LOOKAHEAD(3)    s1 = Term() s2 = Operator() s3 = Term()    {      result = s2 + " " + s1 + " " + s3;    }  | result = Term()  )  {    return result;  }}String Term() :{  Token t, t1, t2;  String s, result;}{  (    t = < Var >    {      result = t.image;    }  | t = < Const >    {      result = t.image;    }  | t = < Number >    {      result = t.image;    }  | < LPAREN > s = Expression() < RPAREN >    {      result = "(" + s + ")";    }  )  {    return result;  }}String Operator() :{}{  (    < ASSIGN >  | < LT >  | < GT >  | < COLON >  | < EQ >  | < LE >  | < GE >  | < NE >  | < SC_OR >  | < SC_AND >  | < PLUS >  | < MINUS >  | < STAR >  | < SLASH >  | < BIT_AND >  | < BIT_OR >  | < XOR >  | < REM >  | < LSHIFT >  )  {    return getToken(0).image;  }}
